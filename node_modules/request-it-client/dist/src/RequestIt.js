"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.RequestIt = void 0;
const http = require("http");
const https = require("https");
const RequestItCookieJar_1 = require("./RequestItCookieJar");
const MAX_REDIRECTS = 3;
const REDIRECT_LIMIT = 20;
const VALID_REDIRECT = new Set([300, 301, 302, 303, 304, 307, 308]);
/** Node.js library for Promise-based, asynchronous http/s requests. */
class RequestIt {
    /** @param {RequestOptions} [options={}] - Default options. Object like NodeJS RequestOptions, but with additional parameters accepted. */
    constructor(options = {}) {
        this.options = this.getSafeOptions(options);
        this.setMaxRedirects(this.options.maxRedirects);
        if (this.isNullOrUndefined(this.options.cookieJar)) {
            this.cookieJar = new RequestItCookieJar_1.RequestItCookieJar();
        }
        else {
            this.cookieJar = RequestItCookieJar_1.RequestItCookieJar.fromCookieJar(this.options.cookieJar);
        }
    }
    isNullOrUndefined(value) {
        return typeof value === 'undefined' || value === null;
    }
    setMaxRedirects(maxRedirects) {
        this.maxRedirects = Math.min(typeof maxRedirects === 'number' ? maxRedirects : MAX_REDIRECTS, REDIRECT_LIMIT);
    }
    getProtocol(url) {
        if (typeof url === 'string' || url instanceof URL) {
            return new URL(url).protocol.toLowerCase().replace(/:/gu, '');
        }
        throw new Error('URL is not one of either "string" or instance of "URL".');
    }
    getSafeOptions(options) {
        if (typeof options === 'string' || options instanceof URL) {
            options = { url: options };
        }
        if (this.isNullOrUndefined(options.followRedirect)) {
            options.followRedirect = true;
        }
        return Object.assign(Object.assign({}, this.options), options);
    }
    cleanUpOptions(options) {
        options = Object.assign({}, options);
        delete options.body;
        delete options.json;
        delete options.rejectBadJson;
        delete options.responseType;
        delete options.url;
        delete options.cookieJar;
        delete options.params;
        delete options.followRedirect;
        return options;
    }
    jsonify(body, json) {
        if (!this.isNullOrUndefined(json) || Array.isArray(body) || (typeof body === 'object' && !Buffer.isBuffer(body))) {
            return true;
        }
        return false;
    }
    prepareBody(body, json, form) {
        if (typeof body === 'string') {
            return Buffer.from(body, 'utf8');
        }
        if (this.jsonify(body, json)) {
            return Buffer.from(JSON.stringify(body || json), 'utf8');
        }
        if (!this.isNullOrUndefined(form)) {
            return Buffer.from(new URLSearchParams(form).toString(), 'utf8');
        }
        if (this.isNullOrUndefined(body)) {
            return Buffer.from('', 'utf8');
        }
        return Buffer.from(body);
    }
    prepareOptions(options, body, cookieString, jsonify, formify) {
        options = this.cleanUpOptions(options);
        let contentTypeExists = false;
        let contentLengthExists = false;
        for (const [key] of Object.entries(options.headers || {})) {
            if (key.toLowerCase() === 'content-type')
                contentTypeExists = true;
            if (key.toLowerCase() === 'content-length')
                contentLengthExists = true;
        }
        if (!contentTypeExists && jsonify) {
            options.headers = Object.assign({ 'Content-Type': 'application/json' }, options.headers);
        }
        if (!contentTypeExists && formify) {
            options.headers = Object.assign({ 'Content-Type': 'application/x-www-form-urlencoded' }, options.headers);
        }
        if (!contentLengthExists) {
            options.headers = Object.assign({ 'Content-Length': body.length }, options.headers);
        }
        if (!this.isNullOrUndefined(cookieString) && cookieString !== '') {
            options.headers.cookie = cookieString;
        }
        return options;
    }
    async quickMethod(method, options = {}) {
        options = Object.assign(Object.assign({}, this.getSafeOptions(options)), { method: method });
        return await this.go(options);
    }
    async go(options = {}, redirectCount = 0) {
        const self = this;
        redirectCount = typeof redirectCount === 'number' ? redirectCount : 0;
        options = this.getSafeOptions(options);
        const promise = new Promise((resolve, reject) => {
            try {
                const { body, params, url, json, form, rejectBadJson, responseType, cookieJar, followRedirect, maxRedirects } = options;
                const internalUrl = new URL(url);
                const internalBody = self.prepareBody(body, json, form);
                const protocol = self.getProtocol(internalUrl) === 'https' ? https : http;
                const jsonify = self.jsonify(body, json);
                const formify = !jsonify && typeof form !== 'undefined';
                const internalCookieJar = typeof cookieJar === 'undefined' ? self.cookieJar : RequestItCookieJar_1.RequestItCookieJar.fromCookieJar(cookieJar);
                const internalOptions = self.prepareOptions(options, internalBody, internalCookieJar.getCookieStringSync(internalUrl.toString()), jsonify, formify);
                internalOptions.method = internalOptions.method || 'GET';
                for (const [key, val] of Object.entries(params || {})) {
                    if (!self.isNullOrUndefined(val)) {
                        internalUrl.searchParams.append(key, val);
                    }
                }
                self.setMaxRedirects(maxRedirects);
                const responseBufs = [];
                const req = protocol.request(internalUrl, internalOptions, (response) => {
                    try {
                        const bodyBufs = [];
                        response.on('data', (data) => bodyBufs.push(data));
                        response.on('error', error => reject(error));
                        response.on('end', () => {
                            try {
                                if (followRedirect &&
                                    response.headers.location &&
                                    VALID_REDIRECT.has(response.statusCode) &&
                                    redirectCount < self.maxRedirects) {
                                    if (typeof response.headers['set-cookie'] === 'undefined') {
                                        return self
                                            .go(Object.assign(Object.assign({}, options), { url: response.headers.location }), redirectCount + 1)
                                            .then((incomingMessage) => resolve(incomingMessage))
                                            .catch((error) => reject(error));
                                    }
                                    else {
                                        const promises = response.headers['set-cookie'].map(cookie => internalCookieJar.setCookie(cookie, internalUrl.toString()).catch(() => { }));
                                        return Promise.all(promises)
                                            .then(() => self
                                            .go(Object.assign(Object.assign({}, options), { url: response.headers.location }), redirectCount + 1)
                                            .then((incomingMessage) => resolve(incomingMessage)))
                                            .catch((error) => reject(error));
                                    }
                                }
                                else if (redirectCount === self.maxRedirects) {
                                    reject(new Error('The number of redirects has exceeded the max of ' + self.maxRedirects.toString()));
                                }
                                const rawResponse = Buffer.concat(responseBufs);
                                const rawBody = Buffer.concat(bodyBufs);
                                response.body = rawBody.toString('utf8');
                                response.cookieJar = internalCookieJar;
                                response.rawBody = rawBody;
                                response.rawResponse = rawResponse;
                                response.json = function json() {
                                    try {
                                        return JSON.parse(rawBody.toString('utf8'));
                                    }
                                    catch (err) {
                                        if (rejectBadJson) {
                                            throw err;
                                        }
                                        else {
                                            return err;
                                        }
                                    }
                                };
                                if (response.statusCode !== 204 &&
                                    (responseType === 'json' ||
                                        (typeof response.headers['content-type'] === 'string' &&
                                            response.headers['content-type'].toLowerCase().startsWith('application/json')))) {
                                    response.body = response.json();
                                }
                                if (typeof response.headers['set-cookie'] === 'undefined') {
                                    resolve(response);
                                }
                                else {
                                    const promises = response.headers['set-cookie'].map(cookie => internalCookieJar.setCookie(cookie, internalUrl.toString()).catch(() => { }));
                                    Promise.all(promises).then(() => resolve(response));
                                }
                            }
                            catch (err) {
                                reject(err);
                            }
                        });
                    }
                    catch (err) {
                        reject(err);
                    }
                });
                req.on('error', error => reject(error));
                req.on('socket', (socket) => {
                    socket.on('data', (data) => responseBufs.push(data));
                });
                req.write(internalBody);
                req.end();
            }
            catch (error) {
                reject(error);
            }
        });
        return promise;
    }
    async get(options = {}) {
        return await this.quickMethod('GET', options);
    }
    async patch(options = {}) {
        return await this.quickMethod('PATCH', options);
    }
    async post(options = {}) {
        return await this.quickMethod('POST', options);
    }
    async put(options = {}) {
        return await this.quickMethod('PUT', options);
    }
    async delete(options = {}) {
        return await this.quickMethod('DELETE', options);
    }
    static async go(options = {}) {
        return await new RequestIt().go(options);
    }
    static async get(options = {}) {
        return await new RequestIt().get(options);
    }
    static async patch(options = {}) {
        return await new RequestIt().patch(options);
    }
    static async post(options = {}) {
        return await new RequestIt().post(options);
    }
    static async put(options = {}) {
        return await new RequestIt().put(options);
    }
    static async delete(options = {}) {
        return await new RequestIt().delete(options);
    }
}
exports.RequestIt = RequestIt;
